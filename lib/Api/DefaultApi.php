<?php
/**
 * DefaultApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Mtn\Momo\Collection
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Collection
 *
 * Enable remote collection of bills, fees or taxes
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Mtn\Momo\Collection\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Mtn\Momo\Collection\ApiException;
use Mtn\Momo\Collection\Configuration;
use Mtn\Momo\Collection\HeaderSelector;
use Mtn\Momo\Collection\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Mtn\Momo\Collection
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'bcAuthorize' => [
            'application/x-www-form-urlencoded',
        ],
        'cancelInvoice' => [
            'application/json',
        ],
        'cancelPreApproval' => [
            'application/json',
        ],
        'createAccessToken' => [
            'application/json',
        ],
        'createInvoice' => [
            'application/json',
        ],
        'createOauth2Token' => [
            'application/x-www-form-urlencoded',
        ],
        'createPayments' => [
            'application/json',
        ],
        'getAccountBalance' => [
            'application/json',
        ],
        'getAccountBalanceInSpecificCurrency' => [
            'application/json',
        ],
        'getApprovedPreApprovals' => [
            'application/json',
        ],
        'getBasicUserinfo' => [
            'application/json',
        ],
        'getInvoiceStatus' => [
            'application/json',
        ],
        'getPaymentStatus' => [
            'application/json',
        ],
        'getPreApprovalStatus' => [
            'application/json',
        ],
        'getUserInfoWithConsent' => [
            'application/json',
        ],
        'preApproval' => [
            'application/json',
        ],
        'requestToWithdrawTransactionStatus' => [
            'application/json',
        ],
        'requestToWithdrawV1' => [
            'application/json',
        ],
        'requestToWithdrawV2' => [
            'application/json',
        ],
        'requesttoPay' => [
            'application/json',
        ],
        'requesttoPayDeliveryNotification' => [
            'application/json',
        ],
        'requesttoPayTransactionStatus' => [
            'application/json',
        ],
        'validateAccountHolderStatus' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation bcAuthorize
     *
     * bc-authorize
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bcAuthorize'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\BcauthorizeResponse
     */
    public function bcAuthorize($authorization, $x_target_environment, $x_callback_url = null, string $contentType = self::contentTypes['bcAuthorize'][0])
    {
        list($response) = $this->bcAuthorizeWithHttpInfo($authorization, $x_target_environment, $x_callback_url, $contentType);
        return $response;
    }

    /**
     * Operation bcAuthorizeWithHttpInfo
     *
     * bc-authorize
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bcAuthorize'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\BcauthorizeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function bcAuthorizeWithHttpInfo($authorization, $x_target_environment, $x_callback_url = null, string $contentType = self::contentTypes['bcAuthorize'][0])
    {
        $request = $this->bcAuthorizeRequest($authorization, $x_target_environment, $x_callback_url, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\BcauthorizeResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\BcauthorizeResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\BcauthorizeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\BcauthorizeResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\BcauthorizeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bcAuthorizeAsync
     *
     * bc-authorize
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bcAuthorize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bcAuthorizeAsync($authorization, $x_target_environment, $x_callback_url = null, string $contentType = self::contentTypes['bcAuthorize'][0])
    {
        return $this->bcAuthorizeAsyncWithHttpInfo($authorization, $x_target_environment, $x_callback_url, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bcAuthorizeAsyncWithHttpInfo
     *
     * bc-authorize
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bcAuthorize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bcAuthorizeAsyncWithHttpInfo($authorization, $x_target_environment, $x_callback_url = null, string $contentType = self::contentTypes['bcAuthorize'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\BcauthorizeResponse';
        $request = $this->bcAuthorizeRequest($authorization, $x_target_environment, $x_callback_url, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bcAuthorize'
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bcAuthorize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bcAuthorizeRequest($authorization, $x_target_environment, $x_callback_url = null, string $contentType = self::contentTypes['bcAuthorize'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling bcAuthorize'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling bcAuthorize'
            );
        }



        $resourcePath = '/v1_0/bc-authorize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelInvoice
     *
     * CancelInvoice
     *
     * @param  string $reference_id UUID of transaction to get result. An id to uniquely identify the cancelling an Invoice (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CancelInvoiceRequest $cancel_invoice_request cancel_invoice_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelInvoice'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\CancelInvoice200Response|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason
     */
    public function cancelInvoice($reference_id, $authorization, $x_target_environment, $x_reference_id, $x_callback_url = null, $cancel_invoice_request = null, string $contentType = self::contentTypes['cancelInvoice'][0])
    {
        list($response) = $this->cancelInvoiceWithHttpInfo($reference_id, $authorization, $x_target_environment, $x_reference_id, $x_callback_url, $cancel_invoice_request, $contentType);
        return $response;
    }

    /**
     * Operation cancelInvoiceWithHttpInfo
     *
     * CancelInvoice
     *
     * @param  string $reference_id UUID of transaction to get result. An id to uniquely identify the cancelling an Invoice (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CancelInvoiceRequest $cancel_invoice_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelInvoice'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\CancelInvoice200Response|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelInvoiceWithHttpInfo($reference_id, $authorization, $x_target_environment, $x_reference_id, $x_callback_url = null, $cancel_invoice_request = null, string $contentType = self::contentTypes['cancelInvoice'][0])
    {
        $request = $this->cancelInvoiceRequest($reference_id, $authorization, $x_target_environment, $x_reference_id, $x_callback_url, $cancel_invoice_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\CancelInvoice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\CancelInvoice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\CancelInvoice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\CancelInvoice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\CancelInvoice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelInvoiceAsync
     *
     * CancelInvoice
     *
     * @param  string $reference_id UUID of transaction to get result. An id to uniquely identify the cancelling an Invoice (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CancelInvoiceRequest $cancel_invoice_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelInvoiceAsync($reference_id, $authorization, $x_target_environment, $x_reference_id, $x_callback_url = null, $cancel_invoice_request = null, string $contentType = self::contentTypes['cancelInvoice'][0])
    {
        return $this->cancelInvoiceAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, $x_reference_id, $x_callback_url, $cancel_invoice_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelInvoiceAsyncWithHttpInfo
     *
     * CancelInvoice
     *
     * @param  string $reference_id UUID of transaction to get result. An id to uniquely identify the cancelling an Invoice (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CancelInvoiceRequest $cancel_invoice_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelInvoiceAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, $x_reference_id, $x_callback_url = null, $cancel_invoice_request = null, string $contentType = self::contentTypes['cancelInvoice'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\CancelInvoice200Response';
        $request = $this->cancelInvoiceRequest($reference_id, $authorization, $x_target_environment, $x_reference_id, $x_callback_url, $cancel_invoice_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelInvoice'
     *
     * @param  string $reference_id UUID of transaction to get result. An id to uniquely identify the cancelling an Invoice (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CancelInvoiceRequest $cancel_invoice_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelInvoiceRequest($reference_id, $authorization, $x_target_environment, $x_reference_id, $x_callback_url = null, $cancel_invoice_request = null, string $contentType = self::contentTypes['cancelInvoice'][0])
    {

        // verify the required parameter 'reference_id' is set
        if ($reference_id === null || (is_array($reference_id) && count($reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reference_id when calling cancelInvoice'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling cancelInvoice'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling cancelInvoice'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling cancelInvoice'
            );
        }




        $resourcePath = '/v2_0/invoice/{referenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }

        // path params
        if ($reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceId' . '}',
                ObjectSerializer::toPathValue($reference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Successful Invoice Deleted', 'Payer not found', 'application/json', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($cancel_invoice_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cancel_invoice_request));
            } else {
                $httpBody = $cancel_invoice_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelPreApproval
     *
     * CancelPreApproval
     *
     * @param  string $preapprovalid UUID of transaction to get result. Reference id  used when creating the PreApproval. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelPreApproval'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cancelPreApproval($preapprovalid, $authorization, $x_target_environment, string $contentType = self::contentTypes['cancelPreApproval'][0])
    {
        $this->cancelPreApprovalWithHttpInfo($preapprovalid, $authorization, $x_target_environment, $contentType);
    }

    /**
     * Operation cancelPreApprovalWithHttpInfo
     *
     * CancelPreApproval
     *
     * @param  string $preapprovalid UUID of transaction to get result. Reference id  used when creating the PreApproval. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelPreApproval'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelPreApprovalWithHttpInfo($preapprovalid, $authorization, $x_target_environment, string $contentType = self::contentTypes['cancelPreApproval'][0])
    {
        $request = $this->cancelPreApprovalRequest($preapprovalid, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelPreApprovalAsync
     *
     * CancelPreApproval
     *
     * @param  string $preapprovalid UUID of transaction to get result. Reference id  used when creating the PreApproval. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelPreApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelPreApprovalAsync($preapprovalid, $authorization, $x_target_environment, string $contentType = self::contentTypes['cancelPreApproval'][0])
    {
        return $this->cancelPreApprovalAsyncWithHttpInfo($preapprovalid, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelPreApprovalAsyncWithHttpInfo
     *
     * CancelPreApproval
     *
     * @param  string $preapprovalid UUID of transaction to get result. Reference id  used when creating the PreApproval. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelPreApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelPreApprovalAsyncWithHttpInfo($preapprovalid, $authorization, $x_target_environment, string $contentType = self::contentTypes['cancelPreApproval'][0])
    {
        $returnType = '';
        $request = $this->cancelPreApprovalRequest($preapprovalid, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelPreApproval'
     *
     * @param  string $preapprovalid UUID of transaction to get result. Reference id  used when creating the PreApproval. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelPreApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelPreApprovalRequest($preapprovalid, $authorization, $x_target_environment, string $contentType = self::contentTypes['cancelPreApproval'][0])
    {

        // verify the required parameter 'preapprovalid' is set
        if ($preapprovalid === null || (is_array($preapprovalid) && count($preapprovalid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $preapprovalid when calling cancelPreApproval'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling cancelPreApproval'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling cancelPreApproval'
            );
        }


        $resourcePath = '/v1_0/preapproval/{preapprovalid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($preapprovalid !== null) {
            $resourcePath = str_replace(
                '{' . 'preapprovalid' . '}',
                ObjectSerializer::toPathValue($preapprovalid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Unspecified internal error', 'Successful request to pay', 'Payer not found', 'application/json', 'Request to pay not found', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAccessToken
     *
     * CreateAccessToken
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccessToken'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\TokenPost200ApplicationJsonResponse|\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse
     */
    public function createAccessToken($authorization, string $contentType = self::contentTypes['createAccessToken'][0])
    {
        list($response) = $this->createAccessTokenWithHttpInfo($authorization, $contentType);
        return $response;
    }

    /**
     * Operation createAccessTokenWithHttpInfo
     *
     * CreateAccessToken
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccessToken'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\TokenPost200ApplicationJsonResponse|\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccessTokenWithHttpInfo($authorization, string $contentType = self::contentTypes['createAccessToken'][0])
    {
        $request = $this->createAccessTokenRequest($authorization, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\TokenPost200ApplicationJsonResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\TokenPost200ApplicationJsonResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\TokenPost200ApplicationJsonResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\TokenPost200ApplicationJsonResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\TokenPost200ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccessTokenAsync
     *
     * CreateAccessToken
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccessTokenAsync($authorization, string $contentType = self::contentTypes['createAccessToken'][0])
    {
        return $this->createAccessTokenAsyncWithHttpInfo($authorization, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccessTokenAsyncWithHttpInfo
     *
     * CreateAccessToken
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccessTokenAsyncWithHttpInfo($authorization, string $contentType = self::contentTypes['createAccessToken'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\TokenPost200ApplicationJsonResponse';
        $request = $this->createAccessTokenRequest($authorization, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccessToken'
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAccessTokenRequest($authorization, string $contentType = self::contentTypes['createAccessToken'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createAccessToken'
            );
        }


        $resourcePath = '/token/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInvoice
     *
     * CreateInvoice
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CreateInvoice $create_invoice create_invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoice'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createInvoice($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $create_invoice = null, string $contentType = self::contentTypes['createInvoice'][0])
    {
        $this->createInvoiceWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $create_invoice, $contentType);
    }

    /**
     * Operation createInvoiceWithHttpInfo
     *
     * CreateInvoice
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CreateInvoice $create_invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoice'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $create_invoice = null, string $contentType = self::contentTypes['createInvoice'][0])
    {
        $request = $this->createInvoiceRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $create_invoice, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createInvoiceAsync
     *
     * CreateInvoice
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CreateInvoice $create_invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceAsync($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $create_invoice = null, string $contentType = self::contentTypes['createInvoice'][0])
    {
        return $this->createInvoiceAsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $create_invoice, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInvoiceAsyncWithHttpInfo
     *
     * CreateInvoice
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CreateInvoice $create_invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceAsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $create_invoice = null, string $contentType = self::contentTypes['createInvoice'][0])
    {
        $returnType = '';
        $request = $this->createInvoiceRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $create_invoice, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInvoice'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CreateInvoice $create_invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createInvoiceRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $create_invoice = null, string $contentType = self::contentTypes['createInvoice'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createInvoice'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling createInvoice'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling createInvoice'
            );
        }




        $resourcePath = '/v2_0/invoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_invoice)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_invoice));
            } else {
                $httpBody = $create_invoice;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOauth2Token
     *
     * CreateOauth2Token
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $grant_type grant_type (optional)
     * @param  string $auth_req_id auth_req_id (optional)
     * @param  string $refresh_token refresh_token (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOauth2Token'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\Oauth2TokenResponse
     */
    public function createOauth2Token($authorization, $x_target_environment, $grant_type = null, $auth_req_id = null, $refresh_token = null, string $contentType = self::contentTypes['createOauth2Token'][0])
    {
        list($response) = $this->createOauth2TokenWithHttpInfo($authorization, $x_target_environment, $grant_type, $auth_req_id, $refresh_token, $contentType);
        return $response;
    }

    /**
     * Operation createOauth2TokenWithHttpInfo
     *
     * CreateOauth2Token
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $grant_type (optional)
     * @param  string $auth_req_id (optional)
     * @param  string $refresh_token (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOauth2Token'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\Oauth2TokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOauth2TokenWithHttpInfo($authorization, $x_target_environment, $grant_type = null, $auth_req_id = null, $refresh_token = null, string $contentType = self::contentTypes['createOauth2Token'][0])
    {
        $request = $this->createOauth2TokenRequest($authorization, $x_target_environment, $grant_type, $auth_req_id, $refresh_token, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\Oauth2TokenResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\Oauth2TokenResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\Oauth2TokenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\Oauth2TokenResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\Oauth2TokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOauth2TokenAsync
     *
     * CreateOauth2Token
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $grant_type (optional)
     * @param  string $auth_req_id (optional)
     * @param  string $refresh_token (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOauth2Token'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOauth2TokenAsync($authorization, $x_target_environment, $grant_type = null, $auth_req_id = null, $refresh_token = null, string $contentType = self::contentTypes['createOauth2Token'][0])
    {
        return $this->createOauth2TokenAsyncWithHttpInfo($authorization, $x_target_environment, $grant_type, $auth_req_id, $refresh_token, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOauth2TokenAsyncWithHttpInfo
     *
     * CreateOauth2Token
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $grant_type (optional)
     * @param  string $auth_req_id (optional)
     * @param  string $refresh_token (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOauth2Token'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOauth2TokenAsyncWithHttpInfo($authorization, $x_target_environment, $grant_type = null, $auth_req_id = null, $refresh_token = null, string $contentType = self::contentTypes['createOauth2Token'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\Oauth2TokenResponse';
        $request = $this->createOauth2TokenRequest($authorization, $x_target_environment, $grant_type, $auth_req_id, $refresh_token, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOauth2Token'
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $grant_type (optional)
     * @param  string $auth_req_id (optional)
     * @param  string $refresh_token (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOauth2Token'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOauth2TokenRequest($authorization, $x_target_environment, $grant_type = null, $auth_req_id = null, $refresh_token = null, string $contentType = self::contentTypes['createOauth2Token'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createOauth2Token'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling createOauth2Token'
            );
        }





        $resourcePath = '/oauth2/token/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }


        // form params
        if ($grant_type !== null) {
            $formParams['grant_type'] = ObjectSerializer::toFormValue($grant_type);
        }
        // form params
        if ($auth_req_id !== null) {
            $formParams['auth_req_id'] = ObjectSerializer::toFormValue($auth_req_id);
        }
        // form params
        if ($refresh_token !== null) {
            $formParams['refresh_token'] = ObjectSerializer::toFormValue($refresh_token);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPayments
     *
     * CreatePayments
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CreatePayments $create_payments create_payments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPayments'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createPayments($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $create_payments = null, string $contentType = self::contentTypes['createPayments'][0])
    {
        $this->createPaymentsWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $create_payments, $contentType);
    }

    /**
     * Operation createPaymentsWithHttpInfo
     *
     * CreatePayments
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CreatePayments $create_payments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPayments'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPaymentsWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $create_payments = null, string $contentType = self::contentTypes['createPayments'][0])
    {
        $request = $this->createPaymentsRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $create_payments, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPaymentsAsync
     *
     * CreatePayments
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CreatePayments $create_payments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentsAsync($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $create_payments = null, string $contentType = self::contentTypes['createPayments'][0])
    {
        return $this->createPaymentsAsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $create_payments, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPaymentsAsyncWithHttpInfo
     *
     * CreatePayments
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CreatePayments $create_payments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentsAsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $create_payments = null, string $contentType = self::contentTypes['createPayments'][0])
    {
        $returnType = '';
        $request = $this->createPaymentsRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $create_payments, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPayments'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\CreatePayments $create_payments (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPaymentsRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $create_payments = null, string $contentType = self::contentTypes['createPayments'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createPayments'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling createPayments'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling createPayments'
            );
        }




        $resourcePath = '/v2_0/payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_payments)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_payments));
            } else {
                $httpBody = $create_payments;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountBalance
     *
     * GetAccountBalance
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalance'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\Balance|\Mtn\Momo\Collection\Model\ErrorReason
     */
    public function getAccountBalance($authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalance'][0])
    {
        list($response) = $this->getAccountBalanceWithHttpInfo($authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getAccountBalanceWithHttpInfo
     *
     * GetAccountBalance
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalance'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\Balance|\Mtn\Momo\Collection\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountBalanceWithHttpInfo($authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalance'][0])
    {
        $request = $this->getAccountBalanceRequest($authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\Balance' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\Balance' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\Balance', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\Balance';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\Balance',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountBalanceAsync
     *
     * GetAccountBalance
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountBalanceAsync($authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalance'][0])
    {
        return $this->getAccountBalanceAsyncWithHttpInfo($authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountBalanceAsyncWithHttpInfo
     *
     * GetAccountBalance
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountBalanceAsyncWithHttpInfo($authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalance'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\Balance';
        $request = $this->getAccountBalanceRequest($authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountBalance'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAccountBalanceRequest($authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalance'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getAccountBalance'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getAccountBalance'
            );
        }


        $resourcePath = '/v1_0/account/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'Incorrect target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountBalanceInSpecificCurrency
     *
     * GetAccountBalanceInSpecificCurrency
     *
     * @param  string $currency Should be in ISO4217 Currency (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalanceInSpecificCurrency'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\Balance|\Mtn\Momo\Collection\Model\ErrorReason
     */
    public function getAccountBalanceInSpecificCurrency($currency, $authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalanceInSpecificCurrency'][0])
    {
        list($response) = $this->getAccountBalanceInSpecificCurrencyWithHttpInfo($currency, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getAccountBalanceInSpecificCurrencyWithHttpInfo
     *
     * GetAccountBalanceInSpecificCurrency
     *
     * @param  string $currency Should be in ISO4217 Currency (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalanceInSpecificCurrency'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\Balance|\Mtn\Momo\Collection\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountBalanceInSpecificCurrencyWithHttpInfo($currency, $authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalanceInSpecificCurrency'][0])
    {
        $request = $this->getAccountBalanceInSpecificCurrencyRequest($currency, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\Balance' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\Balance' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\Balance', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\Balance';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\Balance',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountBalanceInSpecificCurrencyAsync
     *
     * GetAccountBalanceInSpecificCurrency
     *
     * @param  string $currency Should be in ISO4217 Currency (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalanceInSpecificCurrency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountBalanceInSpecificCurrencyAsync($currency, $authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalanceInSpecificCurrency'][0])
    {
        return $this->getAccountBalanceInSpecificCurrencyAsyncWithHttpInfo($currency, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountBalanceInSpecificCurrencyAsyncWithHttpInfo
     *
     * GetAccountBalanceInSpecificCurrency
     *
     * @param  string $currency Should be in ISO4217 Currency (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalanceInSpecificCurrency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountBalanceInSpecificCurrencyAsyncWithHttpInfo($currency, $authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalanceInSpecificCurrency'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\Balance';
        $request = $this->getAccountBalanceInSpecificCurrencyRequest($currency, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountBalanceInSpecificCurrency'
     *
     * @param  string $currency Should be in ISO4217 Currency (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalanceInSpecificCurrency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAccountBalanceInSpecificCurrencyRequest($currency, $authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalanceInSpecificCurrency'][0])
    {

        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling getAccountBalanceInSpecificCurrency'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getAccountBalanceInSpecificCurrency'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getAccountBalanceInSpecificCurrency'
            );
        }


        $resourcePath = '/v1_0/account/balance/{currency}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($currency !== null) {
            $resourcePath = str_replace(
                '{' . 'currency' . '}',
                ObjectSerializer::toPathValue($currency),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'Incorrect target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApprovedPreApprovals
     *
     * GetApprovedPreApprovals
     *
     * @param  string $account_holder_id_type Specifies the type of the accountHolderId.  Allowed values: msisdn email id alias (required)
     * @param  string $account_holder_id The AccountHolderId .  Validated according to the accountHolderIdType: msisdn - Mobile Number. Validated with IsMSISDN. email - E-mail. Validated with IsEmail. id - Internal Id of Account Holder. Validated with IsLongString. alias - Alias of the party. Validated with IsAlias. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApprovedPreApprovals'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\PreApprovalDetails[]|\Mtn\Momo\Collection\Model\ErrorReason
     */
    public function getApprovedPreApprovals($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getApprovedPreApprovals'][0])
    {
        list($response) = $this->getApprovedPreApprovalsWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getApprovedPreApprovalsWithHttpInfo
     *
     * GetApprovedPreApprovals
     *
     * @param  string $account_holder_id_type Specifies the type of the accountHolderId.  Allowed values: msisdn email id alias (required)
     * @param  string $account_holder_id The AccountHolderId .  Validated according to the accountHolderIdType: msisdn - Mobile Number. Validated with IsMSISDN. email - E-mail. Validated with IsEmail. id - Internal Id of Account Holder. Validated with IsLongString. alias - Alias of the party. Validated with IsAlias. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApprovedPreApprovals'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\PreApprovalDetails[]|\Mtn\Momo\Collection\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApprovedPreApprovalsWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getApprovedPreApprovals'][0])
    {
        $request = $this->getApprovedPreApprovalsRequest($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\PreApprovalDetails[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\PreApprovalDetails[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\PreApprovalDetails[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\PreApprovalDetails[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\PreApprovalDetails[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApprovedPreApprovalsAsync
     *
     * GetApprovedPreApprovals
     *
     * @param  string $account_holder_id_type Specifies the type of the accountHolderId.  Allowed values: msisdn email id alias (required)
     * @param  string $account_holder_id The AccountHolderId .  Validated according to the accountHolderIdType: msisdn - Mobile Number. Validated with IsMSISDN. email - E-mail. Validated with IsEmail. id - Internal Id of Account Holder. Validated with IsLongString. alias - Alias of the party. Validated with IsAlias. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApprovedPreApprovals'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovedPreApprovalsAsync($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getApprovedPreApprovals'][0])
    {
        return $this->getApprovedPreApprovalsAsyncWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApprovedPreApprovalsAsyncWithHttpInfo
     *
     * GetApprovedPreApprovals
     *
     * @param  string $account_holder_id_type Specifies the type of the accountHolderId.  Allowed values: msisdn email id alias (required)
     * @param  string $account_holder_id The AccountHolderId .  Validated according to the accountHolderIdType: msisdn - Mobile Number. Validated with IsMSISDN. email - E-mail. Validated with IsEmail. id - Internal Id of Account Holder. Validated with IsLongString. alias - Alias of the party. Validated with IsAlias. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApprovedPreApprovals'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovedPreApprovalsAsyncWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getApprovedPreApprovals'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\PreApprovalDetails[]';
        $request = $this->getApprovedPreApprovalsRequest($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApprovedPreApprovals'
     *
     * @param  string $account_holder_id_type Specifies the type of the accountHolderId.  Allowed values: msisdn email id alias (required)
     * @param  string $account_holder_id The AccountHolderId .  Validated according to the accountHolderIdType: msisdn - Mobile Number. Validated with IsMSISDN. email - E-mail. Validated with IsEmail. id - Internal Id of Account Holder. Validated with IsLongString. alias - Alias of the party. Validated with IsAlias. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApprovedPreApprovals'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApprovedPreApprovalsRequest($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getApprovedPreApprovals'][0])
    {

        // verify the required parameter 'account_holder_id_type' is set
        if ($account_holder_id_type === null || (is_array($account_holder_id_type) && count($account_holder_id_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_holder_id_type when calling getApprovedPreApprovals'
            );
        }

        // verify the required parameter 'account_holder_id' is set
        if ($account_holder_id === null || (is_array($account_holder_id) && count($account_holder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_holder_id when calling getApprovedPreApprovals'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getApprovedPreApprovals'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getApprovedPreApprovals'
            );
        }


        $resourcePath = '/v1_0/preapprovals/{accountHolderIdType}/{accountHolderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($account_holder_id_type !== null) {
            $resourcePath = str_replace(
                '{' . 'accountHolderIdType' . '}',
                ObjectSerializer::toPathValue($account_holder_id_type),
                $resourcePath
            );
        }
        // path params
        if ($account_holder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountHolderId' . '}',
                ObjectSerializer::toPathValue($account_holder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBasicUserinfo
     *
     * GetBasicUserinfo
     *
     * @param  string $account_holder_id_type Type of account holder identity passed in accountHolderId path param.  Possible values: MSISDN  Email  Alias  ID (account ID) (required)
     * @param  string $account_holder_id ID of the account holder. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBasicUserinfo'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\BasicUserInfoJsonResponse|\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse
     */
    public function getBasicUserinfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getBasicUserinfo'][0])
    {
        list($response) = $this->getBasicUserinfoWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getBasicUserinfoWithHttpInfo
     *
     * GetBasicUserinfo
     *
     * @param  string $account_holder_id_type Type of account holder identity passed in accountHolderId path param.  Possible values: MSISDN  Email  Alias  ID (account ID) (required)
     * @param  string $account_holder_id ID of the account holder. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBasicUserinfo'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\BasicUserInfoJsonResponse|\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBasicUserinfoWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getBasicUserinfo'][0])
    {
        $request = $this->getBasicUserinfoRequest($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\BasicUserInfoJsonResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\BasicUserInfoJsonResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\BasicUserInfoJsonResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\BasicUserInfoJsonResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\BasicUserInfoJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\TokenPost401ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBasicUserinfoAsync
     *
     * GetBasicUserinfo
     *
     * @param  string $account_holder_id_type Type of account holder identity passed in accountHolderId path param.  Possible values: MSISDN  Email  Alias  ID (account ID) (required)
     * @param  string $account_holder_id ID of the account holder. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBasicUserinfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBasicUserinfoAsync($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getBasicUserinfo'][0])
    {
        return $this->getBasicUserinfoAsyncWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBasicUserinfoAsyncWithHttpInfo
     *
     * GetBasicUserinfo
     *
     * @param  string $account_holder_id_type Type of account holder identity passed in accountHolderId path param.  Possible values: MSISDN  Email  Alias  ID (account ID) (required)
     * @param  string $account_holder_id ID of the account holder. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBasicUserinfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBasicUserinfoAsyncWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getBasicUserinfo'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\BasicUserInfoJsonResponse';
        $request = $this->getBasicUserinfoRequest($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBasicUserinfo'
     *
     * @param  string $account_holder_id_type Type of account holder identity passed in accountHolderId path param.  Possible values: MSISDN  Email  Alias  ID (account ID) (required)
     * @param  string $account_holder_id ID of the account holder. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBasicUserinfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBasicUserinfoRequest($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getBasicUserinfo'][0])
    {

        // verify the required parameter 'account_holder_id_type' is set
        if ($account_holder_id_type === null || (is_array($account_holder_id_type) && count($account_holder_id_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_holder_id_type when calling getBasicUserinfo'
            );
        }

        // verify the required parameter 'account_holder_id' is set
        if ($account_holder_id === null || (is_array($account_holder_id) && count($account_holder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_holder_id when calling getBasicUserinfo'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getBasicUserinfo'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getBasicUserinfo'
            );
        }


        $resourcePath = '/v1_0/accountholder/{accountHolderIdType}/{accountHolderId}/basicuserinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($account_holder_id_type !== null) {
            $resourcePath = str_replace(
                '{' . 'accountHolderIdType' . '}',
                ObjectSerializer::toPathValue($account_holder_id_type),
                $resourcePath
            );
        }
        // path params
        if ($account_holder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountHolderId' . '}',
                ObjectSerializer::toPathValue($account_holder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceStatus
     *
     * GetInvoiceStatus
     *
     * @param  string $x_reference_id UUID of transaction to get result. Reference id  used when creating the Invoice. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoiceStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\InvoiceResult|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason
     */
    public function getInvoiceStatus($x_reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getInvoiceStatus'][0])
    {
        list($response) = $this->getInvoiceStatusWithHttpInfo($x_reference_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getInvoiceStatusWithHttpInfo
     *
     * GetInvoiceStatus
     *
     * @param  string $x_reference_id UUID of transaction to get result. Reference id  used when creating the Invoice. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoiceStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\InvoiceResult|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceStatusWithHttpInfo($x_reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getInvoiceStatus'][0])
    {
        $request = $this->getInvoiceStatusRequest($x_reference_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\InvoiceResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\InvoiceResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\InvoiceResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\InvoiceResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\InvoiceResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceStatusAsync
     *
     * GetInvoiceStatus
     *
     * @param  string $x_reference_id UUID of transaction to get result. Reference id  used when creating the Invoice. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoiceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceStatusAsync($x_reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getInvoiceStatus'][0])
    {
        return $this->getInvoiceStatusAsyncWithHttpInfo($x_reference_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceStatusAsyncWithHttpInfo
     *
     * GetInvoiceStatus
     *
     * @param  string $x_reference_id UUID of transaction to get result. Reference id  used when creating the Invoice. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoiceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceStatusAsyncWithHttpInfo($x_reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getInvoiceStatus'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\InvoiceResult';
        $request = $this->getInvoiceStatusRequest($x_reference_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceStatus'
     *
     * @param  string $x_reference_id UUID of transaction to get result. Reference id  used when creating the Invoice. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoiceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInvoiceStatusRequest($x_reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getInvoiceStatus'][0])
    {

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling getInvoiceStatus'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getInvoiceStatus'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getInvoiceStatus'
            );
        }


        $resourcePath = '/v2_0/invoice/{x-referenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($x_reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'x-referenceId' . '}',
                ObjectSerializer::toPathValue($x_reference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Successful Invoice Created', 'Payer not found', 'application/json', 'Request to pay not found', 'Unspecified internal error', 'Successful request to pay', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentStatus
     *
     * GetPaymentStatus
     *
     * @param  string $x_reference_id UUID of transaction to get result. Reference id  used when creating the Payment. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\PaymentResult|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason
     */
    public function getPaymentStatus($x_reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getPaymentStatus'][0])
    {
        list($response) = $this->getPaymentStatusWithHttpInfo($x_reference_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getPaymentStatusWithHttpInfo
     *
     * GetPaymentStatus
     *
     * @param  string $x_reference_id UUID of transaction to get result. Reference id  used when creating the Payment. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\PaymentResult|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentStatusWithHttpInfo($x_reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getPaymentStatus'][0])
    {
        $request = $this->getPaymentStatusRequest($x_reference_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\PaymentResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\PaymentResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\PaymentResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\PaymentResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\PaymentResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentStatusAsync
     *
     * GetPaymentStatus
     *
     * @param  string $x_reference_id UUID of transaction to get result. Reference id  used when creating the Payment. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentStatusAsync($x_reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getPaymentStatus'][0])
    {
        return $this->getPaymentStatusAsyncWithHttpInfo($x_reference_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentStatusAsyncWithHttpInfo
     *
     * GetPaymentStatus
     *
     * @param  string $x_reference_id UUID of transaction to get result. Reference id  used when creating the Payment. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentStatusAsyncWithHttpInfo($x_reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getPaymentStatus'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\PaymentResult';
        $request = $this->getPaymentStatusRequest($x_reference_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentStatus'
     *
     * @param  string $x_reference_id UUID of transaction to get result. Reference id  used when creating the Payment. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPaymentStatusRequest($x_reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getPaymentStatus'][0])
    {

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling getPaymentStatus'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getPaymentStatus'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getPaymentStatus'
            );
        }


        $resourcePath = '/v2_0/payment/{x-referenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($x_reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'x-referenceId' . '}',
                ObjectSerializer::toPathValue($x_reference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Successful Payment Created', 'Payer not found', 'application/json', 'Payment not found', 'Unspecified internal error', 'Successful request to pay', 'Request to pay not found', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPreApprovalStatus
     *
     * GetPreApprovalStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the PreApproval. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreApprovalStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\PreApprovalResult|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason
     */
    public function getPreApprovalStatus($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getPreApprovalStatus'][0])
    {
        list($response) = $this->getPreApprovalStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getPreApprovalStatusWithHttpInfo
     *
     * GetPreApprovalStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the PreApproval. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreApprovalStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\PreApprovalResult|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPreApprovalStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getPreApprovalStatus'][0])
    {
        $request = $this->getPreApprovalStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\PreApprovalResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\PreApprovalResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\PreApprovalResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\PreApprovalResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\PreApprovalResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPreApprovalStatusAsync
     *
     * GetPreApprovalStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the PreApproval. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreApprovalStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPreApprovalStatusAsync($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getPreApprovalStatus'][0])
    {
        return $this->getPreApprovalStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPreApprovalStatusAsyncWithHttpInfo
     *
     * GetPreApprovalStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the PreApproval. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreApprovalStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPreApprovalStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getPreApprovalStatus'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\PreApprovalResult';
        $request = $this->getPreApprovalStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPreApprovalStatus'
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the PreApproval. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreApprovalStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPreApprovalStatusRequest($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getPreApprovalStatus'][0])
    {

        // verify the required parameter 'reference_id' is set
        if ($reference_id === null || (is_array($reference_id) && count($reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reference_id when calling getPreApprovalStatus'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getPreApprovalStatus'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getPreApprovalStatus'
            );
        }


        $resourcePath = '/v2_0/preapproval/{referenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceId' . '}',
                ObjectSerializer::toPathValue($reference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Successful Invoice Created', 'Payer not found', 'application/json', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserInfoWithConsent
     *
     * GetUserInfoWithConsent
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfoWithConsent'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\ConsentkycResponse
     */
    public function getUserInfoWithConsent($authorization, $x_target_environment, string $contentType = self::contentTypes['getUserInfoWithConsent'][0])
    {
        list($response) = $this->getUserInfoWithConsentWithHttpInfo($authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getUserInfoWithConsentWithHttpInfo
     *
     * GetUserInfoWithConsent
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfoWithConsent'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\ConsentkycResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserInfoWithConsentWithHttpInfo($authorization, $x_target_environment, string $contentType = self::contentTypes['getUserInfoWithConsent'][0])
    {
        $request = $this->getUserInfoWithConsentRequest($authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\ConsentkycResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ConsentkycResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ConsentkycResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\ConsentkycResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ConsentkycResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserInfoWithConsentAsync
     *
     * GetUserInfoWithConsent
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfoWithConsent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserInfoWithConsentAsync($authorization, $x_target_environment, string $contentType = self::contentTypes['getUserInfoWithConsent'][0])
    {
        return $this->getUserInfoWithConsentAsyncWithHttpInfo($authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserInfoWithConsentAsyncWithHttpInfo
     *
     * GetUserInfoWithConsent
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfoWithConsent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserInfoWithConsentAsyncWithHttpInfo($authorization, $x_target_environment, string $contentType = self::contentTypes['getUserInfoWithConsent'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\ConsentkycResponse';
        $request = $this->getUserInfoWithConsentRequest($authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserInfoWithConsent'
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfoWithConsent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserInfoWithConsentRequest($authorization, $x_target_environment, string $contentType = self::contentTypes['getUserInfoWithConsent'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getUserInfoWithConsent'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getUserInfoWithConsent'
            );
        }


        $resourcePath = '/oauth2/v1_0/userinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation preApproval
     *
     * PreApproval
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\PreApproval $pre_approval pre_approval (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['preApproval'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function preApproval($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $pre_approval = null, string $contentType = self::contentTypes['preApproval'][0])
    {
        $this->preApprovalWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $pre_approval, $contentType);
    }

    /**
     * Operation preApprovalWithHttpInfo
     *
     * PreApproval
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\PreApproval $pre_approval (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['preApproval'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function preApprovalWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $pre_approval = null, string $contentType = self::contentTypes['preApproval'][0])
    {
        $request = $this->preApprovalRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $pre_approval, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation preApprovalAsync
     *
     * PreApproval
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\PreApproval $pre_approval (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['preApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function preApprovalAsync($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $pre_approval = null, string $contentType = self::contentTypes['preApproval'][0])
    {
        return $this->preApprovalAsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $pre_approval, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation preApprovalAsyncWithHttpInfo
     *
     * PreApproval
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\PreApproval $pre_approval (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['preApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function preApprovalAsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $pre_approval = null, string $contentType = self::contentTypes['preApproval'][0])
    {
        $returnType = '';
        $request = $this->preApprovalRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $pre_approval, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'preApproval'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. An id to uniquely identify the making of an invoice (required)
     * @param  string $x_target_environment The desired target environment to use that is allowed for the API user. (required)
     * @param  string $x_callback_url PUT Callback URL to send callback to once the invoice is completed. (optional)
     * @param  \Mtn\Momo\Collection\Model\PreApproval $pre_approval (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['preApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function preApprovalRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $pre_approval = null, string $contentType = self::contentTypes['preApproval'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling preApproval'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling preApproval'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling preApproval'
            );
        }




        $resourcePath = '/v2_0/preapproval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pre_approval)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pre_approval));
            } else {
                $httpBody = $pre_approval;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestToWithdrawTransactionStatus
     *
     * RequestToWithdrawTransactionStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the RequestToWithdraw. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawTransactionStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\RequestToPayResult|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason
     */
    public function requestToWithdrawTransactionStatus($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['requestToWithdrawTransactionStatus'][0])
    {
        list($response) = $this->requestToWithdrawTransactionStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation requestToWithdrawTransactionStatusWithHttpInfo
     *
     * RequestToWithdrawTransactionStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the RequestToWithdraw. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawTransactionStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\RequestToPayResult|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestToWithdrawTransactionStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['requestToWithdrawTransactionStatus'][0])
    {
        $request = $this->requestToWithdrawTransactionStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\RequestToPayResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\RequestToPayResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\RequestToPayResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\RequestToPayResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\RequestToPayResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestToWithdrawTransactionStatusAsync
     *
     * RequestToWithdrawTransactionStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the RequestToWithdraw. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawTransactionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestToWithdrawTransactionStatusAsync($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['requestToWithdrawTransactionStatus'][0])
    {
        return $this->requestToWithdrawTransactionStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestToWithdrawTransactionStatusAsyncWithHttpInfo
     *
     * RequestToWithdrawTransactionStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the RequestToWithdraw. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawTransactionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestToWithdrawTransactionStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['requestToWithdrawTransactionStatus'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\RequestToPayResult';
        $request = $this->requestToWithdrawTransactionStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestToWithdrawTransactionStatus'
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the RequestToWithdraw. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawTransactionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestToWithdrawTransactionStatusRequest($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['requestToWithdrawTransactionStatus'][0])
    {

        // verify the required parameter 'reference_id' is set
        if ($reference_id === null || (is_array($reference_id) && count($reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reference_id when calling requestToWithdrawTransactionStatus'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requestToWithdrawTransactionStatus'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling requestToWithdrawTransactionStatus'
            );
        }


        $resourcePath = '/v1_0/requesttowithdraw/{referenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceId' . '}',
                ObjectSerializer::toPathValue($reference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Successful request to pay', 'Payer not found', 'application/json', 'Request to pay not found', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestToWithdrawV1
     *
     * RequestToWithdraw-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url POST Callback URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawV1'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function requestToWithdrawV1($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requestToWithdrawV1'][0])
    {
        $this->requestToWithdrawV1WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType);
    }

    /**
     * Operation requestToWithdrawV1WithHttpInfo
     *
     * RequestToWithdraw-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url POST Callback URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawV1'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestToWithdrawV1WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requestToWithdrawV1'][0])
    {
        $request = $this->requestToWithdrawV1Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestToWithdrawV1Async
     *
     * RequestToWithdraw-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url POST Callback URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestToWithdrawV1Async($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requestToWithdrawV1'][0])
    {
        return $this->requestToWithdrawV1AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestToWithdrawV1AsyncWithHttpInfo
     *
     * RequestToWithdraw-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url POST Callback URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestToWithdrawV1AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requestToWithdrawV1'][0])
    {
        $returnType = '';
        $request = $this->requestToWithdrawV1Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestToWithdrawV1'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url POST Callback URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestToWithdrawV1Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requestToWithdrawV1'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requestToWithdrawV1'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling requestToWithdrawV1'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling requestToWithdrawV1'
            );
        }




        $resourcePath = '/v1_0/requesttowithdraw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_to_pay)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_to_pay));
            } else {
                $httpBody = $request_to_pay;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestToWithdrawV2
     *
     * RequestToWithdraw-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url PUT Callback URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawV2'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function requestToWithdrawV2($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requestToWithdrawV2'][0])
    {
        $this->requestToWithdrawV2WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType);
    }

    /**
     * Operation requestToWithdrawV2WithHttpInfo
     *
     * RequestToWithdraw-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url PUT Callback URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawV2'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestToWithdrawV2WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requestToWithdrawV2'][0])
    {
        $request = $this->requestToWithdrawV2Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestToWithdrawV2Async
     *
     * RequestToWithdraw-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url PUT Callback URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestToWithdrawV2Async($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requestToWithdrawV2'][0])
    {
        return $this->requestToWithdrawV2AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestToWithdrawV2AsyncWithHttpInfo
     *
     * RequestToWithdraw-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url PUT Callback URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestToWithdrawV2AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requestToWithdrawV2'][0])
    {
        $returnType = '';
        $request = $this->requestToWithdrawV2Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestToWithdrawV2'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url PUT Callback URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestToWithdrawV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestToWithdrawV2Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requestToWithdrawV2'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requestToWithdrawV2'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling requestToWithdrawV2'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling requestToWithdrawV2'
            );
        }




        $resourcePath = '/v2_0/requesttowithdraw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_to_pay)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_to_pay));
            } else {
                $httpBody = $request_to_pay;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requesttoPay
     *
     * RequesttoPay
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPay'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function requesttoPay($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requesttoPay'][0])
    {
        $this->requesttoPayWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType);
    }

    /**
     * Operation requesttoPayWithHttpInfo
     *
     * RequesttoPay
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPay'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function requesttoPayWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requesttoPay'][0])
    {
        $request = $this->requesttoPayRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requesttoPayAsync
     *
     * RequesttoPay
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requesttoPayAsync($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requesttoPay'][0])
    {
        return $this->requesttoPayAsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requesttoPayAsyncWithHttpInfo
     *
     * RequesttoPay
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requesttoPayAsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requesttoPay'][0])
    {
        $returnType = '';
        $request = $this->requesttoPayRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $request_to_pay, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requesttoPay'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example, validating the status of the request. ‘Universal Unique ID’ for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Collection\Model\RequestToPay $request_to_pay (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPay'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requesttoPayRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $request_to_pay = null, string $contentType = self::contentTypes['requesttoPay'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requesttoPay'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling requesttoPay'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling requesttoPay'
            );
        }




        $resourcePath = '/v1_0/requesttopay';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_to_pay)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_to_pay));
            } else {
                $httpBody = $request_to_pay;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requesttoPayDeliveryNotification
     *
     * RequesttoPayDeliveryNotification
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id used when creating the RequesttoPay. (required)
     * @param  string $notification_message The message to send in the delivery notification. Max              length 160. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $language An ISO 639-1 or ISO 639-3 language code. The language is used to select the best matching notification template when sending the delivery notification to the end-user. A default value is used if not specified. (optional)
     * @param  \Mtn\Momo\Collection\Model\Deliverynotification $deliverynotification deliverynotification (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPayDeliveryNotification'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function requesttoPayDeliveryNotification($reference_id, $notification_message, $authorization, $x_target_environment, $language = null, $deliverynotification = null, string $contentType = self::contentTypes['requesttoPayDeliveryNotification'][0])
    {
        $this->requesttoPayDeliveryNotificationWithHttpInfo($reference_id, $notification_message, $authorization, $x_target_environment, $language, $deliverynotification, $contentType);
    }

    /**
     * Operation requesttoPayDeliveryNotificationWithHttpInfo
     *
     * RequesttoPayDeliveryNotification
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id used when creating the RequesttoPay. (required)
     * @param  string $notification_message The message to send in the delivery notification. Max              length 160. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $language An ISO 639-1 or ISO 639-3 language code. The language is used to select the best matching notification template when sending the delivery notification to the end-user. A default value is used if not specified. (optional)
     * @param  \Mtn\Momo\Collection\Model\Deliverynotification $deliverynotification (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPayDeliveryNotification'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function requesttoPayDeliveryNotificationWithHttpInfo($reference_id, $notification_message, $authorization, $x_target_environment, $language = null, $deliverynotification = null, string $contentType = self::contentTypes['requesttoPayDeliveryNotification'][0])
    {
        $request = $this->requesttoPayDeliveryNotificationRequest($reference_id, $notification_message, $authorization, $x_target_environment, $language, $deliverynotification, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation requesttoPayDeliveryNotificationAsync
     *
     * RequesttoPayDeliveryNotification
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id used when creating the RequesttoPay. (required)
     * @param  string $notification_message The message to send in the delivery notification. Max              length 160. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $language An ISO 639-1 or ISO 639-3 language code. The language is used to select the best matching notification template when sending the delivery notification to the end-user. A default value is used if not specified. (optional)
     * @param  \Mtn\Momo\Collection\Model\Deliverynotification $deliverynotification (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPayDeliveryNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requesttoPayDeliveryNotificationAsync($reference_id, $notification_message, $authorization, $x_target_environment, $language = null, $deliverynotification = null, string $contentType = self::contentTypes['requesttoPayDeliveryNotification'][0])
    {
        return $this->requesttoPayDeliveryNotificationAsyncWithHttpInfo($reference_id, $notification_message, $authorization, $x_target_environment, $language, $deliverynotification, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requesttoPayDeliveryNotificationAsyncWithHttpInfo
     *
     * RequesttoPayDeliveryNotification
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id used when creating the RequesttoPay. (required)
     * @param  string $notification_message The message to send in the delivery notification. Max              length 160. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $language An ISO 639-1 or ISO 639-3 language code. The language is used to select the best matching notification template when sending the delivery notification to the end-user. A default value is used if not specified. (optional)
     * @param  \Mtn\Momo\Collection\Model\Deliverynotification $deliverynotification (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPayDeliveryNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requesttoPayDeliveryNotificationAsyncWithHttpInfo($reference_id, $notification_message, $authorization, $x_target_environment, $language = null, $deliverynotification = null, string $contentType = self::contentTypes['requesttoPayDeliveryNotification'][0])
    {
        $returnType = '';
        $request = $this->requesttoPayDeliveryNotificationRequest($reference_id, $notification_message, $authorization, $x_target_environment, $language, $deliverynotification, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requesttoPayDeliveryNotification'
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id used when creating the RequesttoPay. (required)
     * @param  string $notification_message The message to send in the delivery notification. Max              length 160. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $language An ISO 639-1 or ISO 639-3 language code. The language is used to select the best matching notification template when sending the delivery notification to the end-user. A default value is used if not specified. (optional)
     * @param  \Mtn\Momo\Collection\Model\Deliverynotification $deliverynotification (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPayDeliveryNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requesttoPayDeliveryNotificationRequest($reference_id, $notification_message, $authorization, $x_target_environment, $language = null, $deliverynotification = null, string $contentType = self::contentTypes['requesttoPayDeliveryNotification'][0])
    {

        // verify the required parameter 'reference_id' is set
        if ($reference_id === null || (is_array($reference_id) && count($reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reference_id when calling requesttoPayDeliveryNotification'
            );
        }

        // verify the required parameter 'notification_message' is set
        if ($notification_message === null || (is_array($notification_message) && count($notification_message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $notification_message when calling requesttoPayDeliveryNotification'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requesttoPayDeliveryNotification'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling requesttoPayDeliveryNotification'
            );
        }




        $resourcePath = '/v1_0/requesttopay/{referenceId}/deliverynotification';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($notification_message !== null) {
            $headerParams['notificationMessage'] = ObjectSerializer::toHeaderValue($notification_message);
        }
        // header params
        if ($language !== null) {
            $headerParams['Language'] = ObjectSerializer::toHeaderValue($language);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceId' . '}',
                ObjectSerializer::toPathValue($reference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deliverynotification)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deliverynotification));
            } else {
                $httpBody = $deliverynotification;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requesttoPayTransactionStatus
     *
     * RequesttoPayTransactionStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the request to pay. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPayTransactionStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Collection\Model\RequestToPayResult|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason
     */
    public function requesttoPayTransactionStatus($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['requesttoPayTransactionStatus'][0])
    {
        list($response) = $this->requesttoPayTransactionStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation requesttoPayTransactionStatusWithHttpInfo
     *
     * RequesttoPayTransactionStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the request to pay. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPayTransactionStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Collection\Model\RequestToPayResult|\Mtn\Momo\Collection\Model\ErrorReason|\Mtn\Momo\Collection\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function requesttoPayTransactionStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['requesttoPayTransactionStatus'][0])
    {
        $request = $this->requesttoPayTransactionStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Collection\Model\RequestToPayResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\RequestToPayResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\RequestToPayResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Collection\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Collection\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Collection\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Collection\Model\RequestToPayResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\RequestToPayResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requesttoPayTransactionStatusAsync
     *
     * RequesttoPayTransactionStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the request to pay. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPayTransactionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requesttoPayTransactionStatusAsync($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['requesttoPayTransactionStatus'][0])
    {
        return $this->requesttoPayTransactionStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requesttoPayTransactionStatusAsyncWithHttpInfo
     *
     * RequesttoPayTransactionStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the request to pay. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPayTransactionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requesttoPayTransactionStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['requesttoPayTransactionStatus'][0])
    {
        $returnType = '\Mtn\Momo\Collection\Model\RequestToPayResult';
        $request = $this->requesttoPayTransactionStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requesttoPayTransactionStatus'
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the request to pay. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requesttoPayTransactionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requesttoPayTransactionStatusRequest($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['requesttoPayTransactionStatus'][0])
    {

        // verify the required parameter 'reference_id' is set
        if ($reference_id === null || (is_array($reference_id) && count($reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reference_id when calling requesttoPayTransactionStatus'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling requesttoPayTransactionStatus'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling requesttoPayTransactionStatus'
            );
        }


        $resourcePath = '/v1_0/requesttopay/{referenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceId' . '}',
                ObjectSerializer::toPathValue($reference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Successful request to pay', 'Payer not found', 'application/json', 'Request to pay not found', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateAccountHolderStatus
     *
     * ValidateAccountHolderStatus
     *
     * @param  string $account_holder_id The AccountHolder number. Validated according to the AccountHolder ID type (case Sensitive). &lt;br&gt; msisdn - Mobile Number validated according to ITU-T E.164. Validated with IsMSISDN&lt;br&gt; email - Validated to be a valid e-mail format. Validated with IsEmail (required)
     * @param  string $account_holder_id_type Specifies the type of the AccountHolder ID. Allowed values [msisdn, email].  &lt;br&gt; accountHolderId should explicitly be in small letters. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAccountHolderStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateAccountHolderStatus($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, string $contentType = self::contentTypes['validateAccountHolderStatus'][0])
    {
        $this->validateAccountHolderStatusWithHttpInfo($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, $contentType);
    }

    /**
     * Operation validateAccountHolderStatusWithHttpInfo
     *
     * ValidateAccountHolderStatus
     *
     * @param  string $account_holder_id The AccountHolder number. Validated according to the AccountHolder ID type (case Sensitive). &lt;br&gt; msisdn - Mobile Number validated according to ITU-T E.164. Validated with IsMSISDN&lt;br&gt; email - Validated to be a valid e-mail format. Validated with IsEmail (required)
     * @param  string $account_holder_id_type Specifies the type of the AccountHolder ID. Allowed values [msisdn, email].  &lt;br&gt; accountHolderId should explicitly be in small letters. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAccountHolderStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Collection\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateAccountHolderStatusWithHttpInfo($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, string $contentType = self::contentTypes['validateAccountHolderStatus'][0])
    {
        $request = $this->validateAccountHolderStatusRequest($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Collection\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation validateAccountHolderStatusAsync
     *
     * ValidateAccountHolderStatus
     *
     * @param  string $account_holder_id The AccountHolder number. Validated according to the AccountHolder ID type (case Sensitive). &lt;br&gt; msisdn - Mobile Number validated according to ITU-T E.164. Validated with IsMSISDN&lt;br&gt; email - Validated to be a valid e-mail format. Validated with IsEmail (required)
     * @param  string $account_holder_id_type Specifies the type of the AccountHolder ID. Allowed values [msisdn, email].  &lt;br&gt; accountHolderId should explicitly be in small letters. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAccountHolderStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateAccountHolderStatusAsync($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, string $contentType = self::contentTypes['validateAccountHolderStatus'][0])
    {
        return $this->validateAccountHolderStatusAsyncWithHttpInfo($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateAccountHolderStatusAsyncWithHttpInfo
     *
     * ValidateAccountHolderStatus
     *
     * @param  string $account_holder_id The AccountHolder number. Validated according to the AccountHolder ID type (case Sensitive). &lt;br&gt; msisdn - Mobile Number validated according to ITU-T E.164. Validated with IsMSISDN&lt;br&gt; email - Validated to be a valid e-mail format. Validated with IsEmail (required)
     * @param  string $account_holder_id_type Specifies the type of the AccountHolder ID. Allowed values [msisdn, email].  &lt;br&gt; accountHolderId should explicitly be in small letters. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAccountHolderStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateAccountHolderStatusAsyncWithHttpInfo($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, string $contentType = self::contentTypes['validateAccountHolderStatus'][0])
    {
        $returnType = '';
        $request = $this->validateAccountHolderStatusRequest($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateAccountHolderStatus'
     *
     * @param  string $account_holder_id The AccountHolder number. Validated according to the AccountHolder ID type (case Sensitive). &lt;br&gt; msisdn - Mobile Number validated according to ITU-T E.164. Validated with IsMSISDN&lt;br&gt; email - Validated to be a valid e-mail format. Validated with IsEmail (required)
     * @param  string $account_holder_id_type Specifies the type of the AccountHolder ID. Allowed values [msisdn, email].  &lt;br&gt; accountHolderId should explicitly be in small letters. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAccountHolderStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateAccountHolderStatusRequest($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, string $contentType = self::contentTypes['validateAccountHolderStatus'][0])
    {

        // verify the required parameter 'account_holder_id' is set
        if ($account_holder_id === null || (is_array($account_holder_id) && count($account_holder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_holder_id when calling validateAccountHolderStatus'
            );
        }

        // verify the required parameter 'account_holder_id_type' is set
        if ($account_holder_id_type === null || (is_array($account_holder_id_type) && count($account_holder_id_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_holder_id_type when calling validateAccountHolderStatus'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling validateAccountHolderStatus'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling validateAccountHolderStatus'
            );
        }


        $resourcePath = '/v1_0/accountholder/{accountHolderIdType}/{accountHolderId}/active';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($account_holder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountHolderId' . '}',
                ObjectSerializer::toPathValue($account_holder_id),
                $resourcePath
            );
        }
        // path params
        if ($account_holder_id_type !== null) {
            $resourcePath = str_replace(
                '{' . 'accountHolderIdType' . '}',
                ObjectSerializer::toPathValue($account_holder_id_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Incorrect target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
